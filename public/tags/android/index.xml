<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Android on Krishna&#39;s Webplace</title>
    <link>https://krishnayadav.xyz/tags/android/</link>
    <description>Recent content in Android on Krishna&#39;s Webplace</description>
    <generator>Hugo -- 0.147.8</generator>
    <language>en</language>
    <lastBuildDate>Thu, 20 Feb 2025 14:02:45 +0530</lastBuildDate>
    <atom:link href="https://krishnayadav.xyz/tags/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZRAM in WSL2</title>
      <link>https://krishnayadav.xyz/posts/zram-in-wsl2/</link>
      <pubDate>Thu, 20 Feb 2025 14:02:45 +0530</pubDate>
      <guid>https://krishnayadav.xyz/posts/zram-in-wsl2/</guid>
      <description>&lt;p&gt;If you have been using WSL2 on Windows, you would be quite surprised and satisfied at the same time for how well it works as a Linux CLI.&lt;/p&gt;
&lt;p&gt;And so was I, because it allows you the convenience of Windows + the flexibility of Linux systems. It acts as a bridge between the two, and you can run Linux commands on Windows, and Windows commands on Linux.&lt;/p&gt;
&lt;p&gt;For this reason, I use it to build custom ROMs for my Android devices. But with Android 15, the system requirements have been upped from 32gb to 64gb, and I have only 32gb of RAM on my desktop.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>If you have been using WSL2 on Windows, you would be quite surprised and satisfied at the same time for how well it works as a Linux CLI.</p>
<p>And so was I, because it allows you the convenience of Windows + the flexibility of Linux systems. It acts as a bridge between the two, and you can run Linux commands on Windows, and Windows commands on Linux.</p>
<p>For this reason, I use it to build custom ROMs for my Android devices. But with Android 15, the system requirements have been upped from 32gb to 64gb, and I have only 32gb of RAM on my desktop.</p>
<p>When I used to run Ubuntu, I used to use ZRAM to compress the memory and this allowed me to build A15. So I thought, why not use ZRAM in WSL2 as well?</p>
<p>But ZRAM is a kernel module, and WSL2 doesn&rsquo;t have it built into the Linux kernel version 5.15.167.4-microsoft-standard-WSL2. So I had to find a workaround for this.</p>
<p>First I tried modinfo zram, but it returned modinfo: ERROR: Module zram not found. But if you have it listed, try to load it with modprobe zram.</p>
<p>But in my case, I had to build a custom kernel with ZRAM enabled. So I followed the steps below:</p>
<ol>
<li>First install the required packages in WSL2 to build the kernel:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install build-essential flex bison dwarves libssl-dev libelf-dev cpio bc zstd -y
</span></span></code></pre></div><ol start="2">
<li>Then clone the Linux kernel source code from the official Microsoft repository:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone --depth<span class="o">=</span><span class="m">1</span> https://github.com/microsoft/WSL2-Linux-Kernel.git
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> WSL2-Linux-Kernel
</span></span></code></pre></div><ol start="3">
<li>Now we must modify the kernel config to enable ZRAM. (But remember not to do so with the provided 6.6 kernel config in Microsoft/config-wsl.config, as that is known to break Docker, if you are using it with WSL2. If you don&rsquo;t use docker, you can simply copy that to working directory and rename it to .config, else follow as I am doing). Run:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">curl -o .config https://raw.githubusercontent.com/microsoft/WSL2-Linux-Kernel/refs/heads/linux-msft-wsl-6.1.y/arch/x86/configs/config-wsl
</span></span></code></pre></div><p>This gets the 6.1 kernel config that is known to also work with Docker desktop.</p>
<ol start="4">
<li>Then let&rsquo;s fire up the gui based kernel configuration tool:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">make menuconfig
</span></span></code></pre></div><ol start="5">
<li>This should open the menu. Navigate to the following place to enable ZSTD [or any other compression algorithm you prefer]:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Crypto API → Compression → &lt;*&gt; ZSTD compression algorithm
</span></span><span class="line"><span class="cl">Cryptographic API ---&gt;
</span></span><span class="line"><span class="cl">    Compression ---&gt;
</span></span><span class="line"><span class="cl">        &lt;*&gt; zstd
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/enable_ZSTD.png#center"/> 
</figure>

<ol start="6">
<li>Go back to the main menu and navigate to the following place to enable ZRAM:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Device Drivers  ---&gt;
</span></span><span class="line"><span class="cl">    <span class="o">[</span>*<span class="o">]</span> Block devices  ---&gt;
</span></span><span class="line"><span class="cl">        &lt;*&gt; Compressed RAM block device support 
</span></span><span class="line"><span class="cl">        <span class="o">[</span>*<span class="o">]</span> Write back incompressible or idle page to backing device 
</span></span><span class="line"><span class="cl">        <span class="o">[</span>*<span class="o">]</span> Track zRam block status 
</span></span></code></pre></div><p>Make sure to Change “Compressed RAM block device support” from M to *, if it was previously set to M. To change it, simply press ‘Y’ at this option. M means a kernel module that can be loaded separately, and &lsquo;Y&rsquo; means that it will be built-in. In WSL2 Loadable module support is disabled when using a custom built kernel. We must set any modules to be built-in before building.</p>
<ol start="7">
<li>In this same place under &ldquo;Compressed RAM block device support&rdquo;, you can also set the compression algorithm via the submenu &ldquo;Default ZRAM compressor&rdquo;. I set it to ZSTD.</li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="/img/setting_COMP_Algo.png#center"/> 
</figure>

<ol start="8">
<li>Finally save the config from bottom menu panel and exit. Let us now compile the kernel with:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">make -j<span class="k">$(</span>nproc<span class="k">)</span>
</span></span></code></pre></div><p>This will take some time, so be patient. After it is done, we can find the compilled kernel in the arch/x86/boot/ directory. It will be named as <strong>bzImage</strong>.</p>
<ol start="9">
<li>Open the Windows file explorer and navigate to the WSL2 directory where you have the kernel compiled. Then copy the kernel to the Windows directory:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cp arch/x86/boot/bzImage /mnt/c/Users/&lt;Your Windows Username&gt;/Downloads/
</span></span></code></pre></div><p>Now we can move this image anywhere we want. I created a folder named &lsquo;.wsl-kernel&rsquo; in my C:\Users&lt;Username&gt; directory and moved it there.</p>
<ol start="10">
<li>The WSL2 kernel must also be overwritten with this new kernel. Simply go to the C:\Users&lt;Username&gt; location and create a .wslconfig file with the following content:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="p">[</span><span class="no">wsl2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">kernel</span><span class="p">=</span><span class="n">C:</span><span class="p">\\</span><span class="n">Users</span><span class="p">\\&lt;</span><span class="n">Username</span><span class="p">&gt;\\.</span><span class="nb">wsl-kernel</span><span class="p">\\</span><span class="n">bzImage</span>
</span></span></code></pre></div><ol start="11">
<li>Now we have to restart the WSL2 instance. You can do so by running:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-powershell" data-lang="powershell"><span class="line"><span class="cl"><span class="n">wsl</span> <span class="err">–</span><span class="n">shutdown</span>
</span></span><span class="line"><span class="cl"><span class="n">wsl</span>
</span></span></code></pre></div><p>Check the kernel version by running this command to verify that it is the one you compiled:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">uname -sr
</span></span></code></pre></div><p>It should show the latest kernel version that you compiled. For example it shows me <strong>Linux 6.6.36.6-microsoft-standard-WSL2</strong>.</p>
<ol start="12">
<li>Although you have loaded the kernel, if you try checking for the zram module using modinfo, it will still not be there. We must first install the modules we built. Run this from the git repository we cloned:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo make modules_install
</span></span><span class="line"><span class="cl"><span class="c1">#Now load them:</span>
</span></span><span class="line"><span class="cl">sudo modprobe
</span></span></code></pre></div><ol start="13">
<li>If we now check for the zram module, it should be there. You can also check the zram devices with:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">modinfo zram
</span></span></code></pre></div><ol start="14">
<li>Now, we must enable zram to be accessible always on boot, i.e., make it persistent. To do so, we must create a systemd service. Run:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo nano /etc/systemd/system/zram.service
</span></span></code></pre></div><p>Add the following content to the file:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">###REMEMBER! Change the 1G in ExecStart to whatever size of zram block device you wish to create.</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>Unit<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Description</span><span class="o">=</span>Enable ZRAM Swap
</span></span><span class="line"><span class="cl"><span class="nv">After</span><span class="o">=</span>multi-user.target
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Service<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">Type</span><span class="o">=</span>oneshot
</span></span><span class="line"><span class="cl"><span class="nv">ExecStart</span><span class="o">=</span>/bin/bash -c <span class="s2">&#34;echo 1G &gt; /sys/block/zram0/disksize &amp;&amp; mkswap /dev/zram0 &amp;&amp; swapon /dev/zram0 -p 10&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">RemainAfterExit</span><span class="o">=</span><span class="nb">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>Install<span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</span></span></code></pre></div><p>Enable the service with:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo systemctl <span class="nb">enable</span> zram.service
</span></span><span class="line"><span class="cl">sudo systemctl start zram.service
</span></span></code></pre></div><p><strong>Now ZRAM should be enabled and working on your WSL2 instance.</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>Whatsapp Without Phone</title>
      <link>https://krishnayadav.xyz/posts/whatsapp-without-phone/</link>
      <pubDate>Wed, 29 May 2024 20:43:23 +0530</pubDate>
      <guid>https://krishnayadav.xyz/posts/whatsapp-without-phone/</guid>
      <description>&lt;p&gt;I had stopped using whatsapp because I didn&amp;rsquo;t want to have it&amp;rsquo;s proprietary app on my de-googled device.&lt;/p&gt;
&lt;h3 id=&#34;the-issue&#34;&gt;The Issue&lt;/h3&gt;
&lt;p&gt;But you see, this application is used by most of my academic professors and other colleages, so I had to somehow use it (without the app on my phone, of course).&lt;/p&gt;
&lt;p&gt;So I thought of running it through some android emulator, but didn&amp;rsquo;t want to natively run it on my linux machine. [No waydroid as I run X11]&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>I had stopped using whatsapp because I didn&rsquo;t want to have it&rsquo;s proprietary app on my de-googled device.</p>
<h3 id="the-issue">The Issue</h3>
<p>But you see, this application is used by most of my academic professors and other colleages, so I had to somehow use it (without the app on my phone, of course).</p>
<p>So I thought of running it through some android emulator, but didn&rsquo;t want to natively run it on my linux machine. [No waydroid as I run X11]</p>
<p>Thus I installed Windows 10 through virtual box and then installed bluestacks in it. But bluestacks was not starting properly (issues with virtualization), which I solved via virtualbox settings.</p>
<figure class="align-center ">
    <img loading="lazy" src="/img/enable_virt.png#center"
         alt="Had to enable the above 2 options to get virtualization working."/> <figcaption>
            <p>Had to enable the above 2 options to get virtualization working.</p>
        </figcaption>
</figure>

<p><em>If this still doesn&rsquo;t work for you, I think you should also enable Virtualization and Hyper-V support from &ldquo;Turn on windows features&rdquo; from within your Windows VM.</em></p>
<p>After this, bluestacks started working normally and I installed whatsapp in it and logged in to my account <em>[A strange thing was that all my chats and groups were gone, but maybe that was because I was logging in after around 1 month].</em></p>
<p>My next major work was to get whatsapp web working, so that I could use it on my other devices (of course, not going to run the emulator each time I have to use it).</p>
<p>To do so, whatsapp requires web versions to have their QR code scanned by the whatsapp application for login, so I used a usb camera that I had with me, but I got this error when I tried to use the webcam in my Windows VM:</p>
<figure class="align-center ">
    <img loading="lazy" src="/img/cam_notFound_big.png#center"/> 
</figure>

<p>It required a &ldquo;Webcam Passthrough&rdquo;, so that the VM instance could access the USB camera.</p>
<h3 id="steps-to-allow-webcam-passthrough-credits">Steps to allow Webcam Passthrough [<a href="https://askubuntu.com/a/1237808">Credits</a>]:</h3>
<ol>
<li>
<p>First install certain extra packages to get stuff working:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-get install virtualbox-guest-additions-iso virtualbox-ext-pack
</span></span></code></pre></div></li>
<li>
<p>Next, we need to find our webcam details using this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">VBoxManage list webcams
</span></span></code></pre></div><p>This should show us a list of (for me only 1) webcam/s attached to your host device.</p>
</li>
<li>
<p>Now finally we need to connect this webcam to enable passthrough. Issue this command, by replacing the word <strong>Windows</strong> with the name of your VM instance and the .1 with the number that corresponds to your webcam as listed in step 2 (in most cases, it should be .1):</p>
<p><em><strong>NOTE: This command must be run only when your windows VM is running.</strong></em></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">VBoxManage controlvm <span class="s2">&#34;Windows&#34;</span> webcam attach .1
</span></span></code></pre></div></li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="/img/list_Webcam.png#center"/> 
</figure>

<p><em>NOTE: If you shutdown or restart your VM, it will loose access to the camera. You need to re-run the step 3 command to get it working.</em></p>
<h3 id="conclusion">Conclusion</h3>
<p>With this much, my VM was able to detect the webcam and without much difficulty, I was able to register with the whatsapp web version on my devices.</p>
<p>A small caveat though, remember to open the whatsapp in your windows VM every 14 days to avoid getting logged out of your whatsapp web devices.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Sign a Custom ROM Build</title>
      <link>https://krishnayadav.xyz/posts/sign-a-custom-rom-build/</link>
      <pubDate>Sun, 26 May 2024 21:05:20 +0530</pubDate>
      <guid>https://krishnayadav.xyz/posts/sign-a-custom-rom-build/</guid>
      <description>&lt;p&gt;This guide will explain how to &lt;strong&gt;sign&lt;/strong&gt; a Custom ROM build (typically unofficial builds, as most official ROMs are now shipping their own private keys).&lt;/p&gt;
&lt;p&gt;I will use the &lt;a href=&#34;https://wiki.lineageos.org/signing_builds&#34;&gt;Lineage wiki guide&lt;/a&gt;, but simplify it in my own words at places where I feel this guide did not give more practical information to a new comer like me.&lt;/p&gt;
&lt;h4 id=&#34;the-steps-to-generate-the-keys-are-as-follows&#34;&gt;The steps to generate the keys are as follows:&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: You only need to run this once. If you ever rerun these, you’ll need to migrate between builds.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>This guide will explain how to <strong>sign</strong> a Custom ROM build (typically unofficial builds, as most official ROMs are now shipping their own private keys).</p>
<p>I will use the <a href="https://wiki.lineageos.org/signing_builds">Lineage wiki guide</a>, but simplify it in my own words at places where I feel this guide did not give more practical information to a new comer like me.</p>
<h4 id="the-steps-to-generate-the-keys-are-as-follows">The steps to generate the keys are as follows:</h4>
<p><strong>NOTE</strong>: You only need to run this once. If you ever rerun these, you’ll need to migrate between builds.</p>
<ol>
<li>
<p>Go to the directory where all yours rom files are originally synced (the root of your custom rom files). Now open a terminal and issue this command:</p>
<p><strong>NOTE</strong>: Please note this beforehand that running the following code will ask you to enter password for several keys and several number of times. I will say that just enter 1 password and copy+paste it on all the places where it asks for a password to be entered.</p>
<p><strong><em>DO NOTE THIS PASSWORD DOWN, as we will have to use it when we sign the builds.</em></strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">subject</span><span class="o">=</span><span class="s1">&#39;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&#39;</span>
</span></span><span class="line"><span class="cl">mkdir ~/.android-certs
</span></span><span class="line"><span class="cl"><span class="k">for</span> cert in bluetooth cyngn-app media networkstack platform releasekey sdk_sandbox shared testcert testkey verity<span class="p">;</span> <span class="k">do</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ./development/tools/make_key ~/.android-certs/<span class="nv">$cert</span> <span class="s2">&#34;</span><span class="nv">$subject</span><span class="s2">&#34;</span><span class="p">;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span><span class="k">done</span>
</span></span></code></pre></div></li>
<li>
<p>Now we are required to re-sign APEX keys. To do so, simply run the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cp ./development/tools/make_key ~/.android-certs/
</span></span><span class="line"><span class="cl">sed -i <span class="s1">&#39;s|2048|4096|g&#39;</span> ~/.android-certs/make_key
</span></span></code></pre></div></li>
<li>
<p>Now finally, we must generate our keys. I will strongly recommend you to generate them <strong>with</strong> a password (re-use the password you used in step 1).</p>
<p>The command to run is in <a href="https://wiki.lineageos.org/signing_builds#generate-keys-with-a-password">here</a></p>
<p><strong>NOTE</strong>: If you have issues following up with these steps, I have a script that will execute the commands for you (of course, you have to manually enter the password for each keys). You can find that script <a href="https://github.com/ObsidianMaximus/scripts/blob/master/signing/Generate_Keys.sh">here</a></p>
<p>Usage (copy paste this in terminal):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">curl -O https://raw.githubusercontent.com/ObsidianMaximus/scripts/master/signing/Generate_Keys.sh
</span></span><span class="line"><span class="cl">bash Generate_Keys.sh
</span></span></code></pre></div></li>
</ol>
<h4 id="now-the-steps-to-make-a-zip-flashable-package-are-as-follows">Now, the steps to <strong>make a .zip flashable package</strong> are as follows:</h4>
<ol>
<li>
<p>Source the envsetup.sh by executing this command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">source</span> build/envsetup.sh
</span></span></code></pre></div></li>
<li>
<p>Now finally, we will have to start compiling the files for our custom ROM (this will take a long time, depending on your computer&rsquo;s specs). To do so, run the following command (replacing the codename with your device codename):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">breakfast &lt;codename&gt;
</span></span><span class="line"><span class="cl">mka target-files-package otatools
</span></span></code></pre></div></li>
<li>
<p>Now, it is time to sign all of our APKs and APEXes and build the .zip package.</p>
<p>We will use 2 environment variables to ease our task, as they will allow us to sign without having to enter the password several times. For that, we must issue these 2 commands in the terminal:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">ANDROID_PW_FILE</span><span class="o">=</span>/path/to/your/password/file
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">EDITOR</span><span class="o">=</span>your_preferred_text_editor
</span></span></code></pre></div><p><strong>NOTE</strong>: <em>Replace the fields above as required. For the <strong>ANDROID_PW_FILE</strong>, just create a file somewhere and input its path there. As for the <strong>EDITOR</strong> variable, choose whichever editor you like (eg. vim, nano, codium, etc).</em></p>
<p>Next run the following commands to call the script to start signing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">curl -O https://raw.githubusercontent.com/ObsidianMaximus/scripts/master/signing/Sign.sh
</span></span><span class="line"><span class="cl">bash Sign.sh
</span></span></code></pre></div><p><strong>NOTE</strong>: <em>This script will invoke a command &ldquo;<strong>sign_target_files_apks</strong>&rdquo;, which should open the editor which you specified above, but if it does not, then open the file that you had given above in <strong>&ldquo;ANDROID_PW_FILE&rdquo;</strong> and you should have stuff inside of it with empty spaces in these &ldquo;[[[      ]]]&rdquo; brackets.</em></p>
<p>Fill the password in this empty space for all the apks [make sure to fill it between the 3 left and 3 right brackets], and then save this file, and re-run the above script by simple doing: <strong><code>bash Sign.sh</code></strong>.</p>
<p><strong>NOTE</strong>: Wait patiently, it can take some time to do all of the above process.</p>
</li>
</ol>
<p>Congratulations, you have successfully signed the build. Now in case you are wondering where the .zip file is (no, it is not in the usual out/ directory), the .zip is right in the android root tree, where you issued the commands from.</p>
<p>Just clean flash the <strong>signed-ota_update.zip</strong> and device integrity should be met now.</p>
<hr>
<p><strong>Update:</strong> Just confirmed that dirty flashing this build over the previous unsigned ROM also works.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Use SSH or Rsync With Android</title>
      <link>https://krishnayadav.xyz/posts/use-ssh-or-rsync-with-android/</link>
      <pubDate>Fri, 26 Apr 2024 09:28:58 +0530</pubDate>
      <guid>https://krishnayadav.xyz/posts/use-ssh-or-rsync-with-android/</guid>
      <description>&lt;p&gt;Today, I wanted to send a file from my desktop to my android device. I thought of using rsync for this purpose, which is a tool that I use frequently to sync files between my desktop and my laptop.&lt;/p&gt;
&lt;p&gt;I thought of giving it a try and came across &lt;a href=&#34;https://howtos.davidsebek.com/android-rsync-termux.html&#34;&gt;this great article&lt;/a&gt; that explained just this.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE: This guide requires both the computer and the Android device to be on the same wifi network.&lt;/strong&gt;&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Today, I wanted to send a file from my desktop to my android device. I thought of using rsync for this purpose, which is a tool that I use frequently to sync files between my desktop and my laptop.</p>
<p>I thought of giving it a try and came across <a href="https://howtos.davidsebek.com/android-rsync-termux.html">this great article</a> that explained just this.</p>
<p><strong>NOTE: This guide requires both the computer and the Android device to be on the same wifi network.</strong></p>
<h3 id="the-process-to-send-files-from-pc-to-android">The process to send files from PC to Android</h3>
<ol>
<li>Install rsync on termux using the command: <strong><code>apt install rsync</code></strong> and install openssh using the command: <strong><code>apt install openssh</code></strong>.</li>
<li>Then setup the internal storage of our Android device to be accessible by termux using the command: <strong><code>termux-setup-storage</code></strong>. Grant termux the permission to access storage when prompted.</li>
<li>Now, change the sshd config file to allow termux to use SSH port. Termux does not have the permission to use the default SSH port 22, so we will use 8022 port instead (can use any available port). For doing this, edit the ../usr/etc/ssh/sshd_config file by simply using the command: <strong><code>echo &quot;Port 8022&quot; &gt;&gt; ../usr/etc/ssh/sshd_config</code></strong></li>
<li>Let&rsquo;s get the local ip address of our device by using the command: <strong><code>ifconfig</code></strong>. The ip address should be usually in the end and will be after &ldquo;inet&rdquo; . Or you can just go to Settings app and click on wifi and select the wifi you are connected to and look for the ipv4 address. In either of these 2 cases, the ip address should usually begin with <strong>192.168.xx.xx</strong> where x&rsquo;s are to be replaced by your ip address part.</li>
<li>Setup a password for the user by using the command: <strong><code>passwd</code></strong>.</li>
<li>Finally, we have to start the SSH daemon. To do this, enter this in termux: <strong><code>sshd</code></strong>.</li>
</ol>
<h4 id="for-using-ssh">For using SSH</h4>
<ol>
<li>Open terminal on your pc and type: <strong><code>ssh -p 8022 192.168.xx.xx</code></strong> [where the x&rsquo;s are replaced by your ipv4 address part].</li>
<li>You should now be able to use android terminal through your desktop terminal.</li>
</ol>
<h4 id="for-using-rsync">For using Rsync</h4>
<ol>
<li>
<p>Simply enter the command : <strong><code>rsync -e 'ssh -p 8022' &lt;file to transfer from pc&gt; 192.168.xx.xx:/data/data/com.termux/files/home/storage/</code></strong></p>
<p>Explanation of some stuff in the above commands :</p>
<ul>
<li>The -e command is used to specify the remote shell to use. For more details, check the manpage of rsync.</li>
<li>The x&rsquo;s replace your ipv4 address parts.</li>
<li><strong>/data/data/com.termux/files/home/storage/</strong> is the &ldquo;usual&rdquo; path of the main storage in our Android which the user can access, so we are sending the file from our desktop to our Android device&rsquo;s internal storage using this. You can specify some folder to send the file into directly by simply adding the folder after <strong>storage/</strong> in the command. If this shows an error message when you try to transfer files, just type: <strong><code>pwd</code></strong> in termux to get your current directory where you wish to send/receive the files and replace output of this command with the path in the step 1 command above after your phone&rsquo;s ip address.</li>
<li>This should work in vice-versa as well. Just add the path to copy from Android first and the path to copy to in your desktop after this.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="note">Note</h3>
<ul>
<li>
<p>To avoid entering password all the time while accessing SSH/Rsync, generate a key pair on your pc using the command: <strong><code>ssh-keygen -t ed25519</code></strong> and then copy it to Android using the command: <strong><code>ssh-copy-id -p 8022 192.168.xx.xx</code></strong> in your desktop terminal. This will ask you password only once and after authenticating it, you can now just use SSH/Rsync without entering that password which we generated in the &ldquo;Step 5&rdquo; in the beginning.</p>
</li>
<li>
<p><strong>REMEMBER</strong> that the ip address of your android device can change from time to time due to ip addresses being dynamic when using wifi. Or they &ldquo;may&rdquo; change if the router is restarted. In any case, be sure to repeat the &ldquo;Step 4&rdquo; which we did in the beginning to find our local ip address.</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Ubuntu Touch Port Part 1</title>
      <link>https://krishnayadav.xyz/posts/ubuntu-touch-port-part-1/</link>
      <pubDate>Thu, 25 Apr 2024 13:38:00 +0530</pubDate>
      <guid>https://krishnayadav.xyz/posts/ubuntu-touch-port-part-1/</guid>
      <description>&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;So I recently decided to get more involved in the Android world and came about a &amp;rsquo;new&amp;rsquo; type of OS, known as Ubuntu Touch. I thought a bit on it and decided to start the porting process for it for my device Realme GT Neo 2 [codenamed:bitra].&lt;/p&gt;
&lt;p&gt;I started with the &lt;a href=&#34;https://docs.ubports.com/en/latest/porting/introduction/index.html&#34;&gt;official documentation of UBports&lt;/a&gt; where in they gave some good amount of introduction on how and why certain things needed to be done.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="getting-started">Getting Started</h2>
<p>So I recently decided to get more involved in the Android world and came about a &rsquo;new&rsquo; type of OS, known as Ubuntu Touch. I thought a bit on it and decided to start the porting process for it for my device Realme GT Neo 2 [codenamed:bitra].</p>
<p>I started with the <a href="https://docs.ubports.com/en/latest/porting/introduction/index.html">official documentation of UBports</a> where in they gave some good amount of introduction on how and why certain things needed to be done.</p>
<p>The guide mentions the use of GSI for devices with Android 8+ and, as my device is indeed treble supported, I think I will head to using GSI only.</p>
<p><a href="https://docs.ubports.com/en/latest/porting/build_and_boot/standalone_kernel_build.html">Standalone Kernel Method (Halium 9 and newer)</a> is very interesting as it seems to be the least tiresome way for porting among all of the 3 mentioned methods. So I started with this and did the steps as mentioned in the guide.</p>
<p>The defconfig that i had to use is the <a href="https://gitlab.com/Krishna-Yadav/android_kernel_realme_sm8250/-/blob/master/arch/arm64/configs/vendor/sm8250_defconfig?ref_type=heads">sm8250_defconfig</a>. Next i made a halium.config file as prompted.</p>
<p>Next, i had to fill in the deviceinfo file. For this purpose, I used the <a href="https://gitlab.com/ubports/porting/community-ports/android11/xiaomi-poco-x3-pro/xiaomi-vayu">Poco X3 Pro device branch</a> as a dummy template and started filling stuff according to it and the guide.</p>
<p>But I got stuck on the <em>deviceinfo_bootimg_prebuilt_dtb</em> step as i was not sure where to find my dtb. So i asked this question in the telegram group of Ubports and was recommended to run a script on the <a href="/bootimageextractionguide/index.html">boot.img which i had extracted</a>.</p>
<p>The script was by LOS. It can be found <a href="https://raw.githubusercontent.com/LineageOS/android_system_tools_mkbootimg/lineage-18.1/unpack_bootimg.py">here</a> [use it through curl -O options]. And it worked! I was able to get the output from my boot.img using the script by running this command : <strong><code>python unpack_bootimg.py --boot_img boot.img</code></strong></p>
<figure class="align-center ">
    <img loading="lazy" src="/img/pyScriptLOS18.png#center"
         alt="The script&rsquo;s output in normal format."/> <figcaption>
            <p>The script&rsquo;s output in normal format.</p>
        </figcaption>
</figure>

<p>But then, i was recommended to add the option <strong><code>--format mkbootimg</code></strong> along with the above command to get the outputed text in terms of mkbootimg arguments, as it would output the values that were expected for the <strong>deviceinfo</strong> file.</p>
<p>Unfortunately for me though, adding that option to the command gave me an error : <strong><code>error: unrecognized arguments: --format mkbootimg</code></strong></p>
<p>I then thought and checked the latest LOS branch from where i had got that previous script. And i did find an updated script from LOS21 that did have those options that i needed for mkbootimg format. The new script can be found <a href="https://raw.githubusercontent.com/LineageOS/android_system_tools_mkbootimg/lineage-21.0/unpack_bootimg.py">here</a></p>
<p>After this, i ran the command again, now with the additional parameters to it and was indeed able to generate the output in mkbootimg format without any errors! The updated command : <strong><code>python unpack_bootimg.py --boot_img boot.img --format mkbootimg</code></strong></p>
<figure class="align-center ">
    <img loading="lazy" src="/img/pyScriptLOS21.png#center"
         alt="The script&rsquo;s output in mkbootimg format."/> <figcaption>
            <p>The script&rsquo;s output in mkbootimg format.</p>
        </figcaption>
</figure>

<p>This has given me alot to work with now. I will be looking forward to progress even further and complete the deviceinfo file.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Boot Image Extraction Guide</title>
      <link>https://krishnayadav.xyz/posts/boot-image-extraction-guide/</link>
      <pubDate>Wed, 24 Apr 2024 21:53:31 +0530</pubDate>
      <guid>https://krishnayadav.xyz/posts/boot-image-extraction-guide/</guid>
      <description>&lt;p&gt;Guide on how to extract a boot image from any Android phone [Requires Magisk and Computer]&lt;/p&gt;
&lt;h2 id=&#34;getting-started&#34;&gt;Getting started!&lt;/h2&gt;
&lt;p&gt;Accessing and modifying system files on your device typically requires superuser permissions. To extract the boot image, we&amp;rsquo;ll need a root environment. We&amp;rsquo;ll achieve this by using Magisk.&lt;/p&gt;
&lt;h4 id=&#34;procedure&#34;&gt;Procedure&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;First, make sure you install TWRP and then flash Magisk through it.&lt;/li&gt;
&lt;li&gt;Setup Magisk in your phone.&lt;/li&gt;
&lt;li&gt;Connect your phone to your Computer and type adb shell [Ensure that you have adb setup properly].&lt;/li&gt;
&lt;li&gt;Now, become root by typing &lt;strong&gt;su&lt;/strong&gt; in the shell on your PC.&lt;/li&gt;
&lt;li&gt;Copy/Paste the following code in the shell.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; PARTITION in &lt;span class=&#34;s2&#34;&gt;&amp;#34;boot&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;boot_a&amp;#34;&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;boot_b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nv&#34;&gt;BLOCK&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;find /dev/block &lt;span class=&#34;se&#34;&gt;\(&lt;/span&gt; -type b -o -type c -o -type l &lt;span class=&#34;se&#34;&gt;\)&lt;/span&gt; -iname &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$PARTITION&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; -print -quit 2&amp;gt;/dev/null&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -n &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BLOCK&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$PARTITION&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;readlink -f &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$BLOCK&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command will display the boot partition paths for both A/B and A-only devices.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Guide on how to extract a boot image from any Android phone [Requires Magisk and Computer]</p>
<h2 id="getting-started">Getting started!</h2>
<p>Accessing and modifying system files on your device typically requires superuser permissions. To extract the boot image, we&rsquo;ll need a root environment. We&rsquo;ll achieve this by using Magisk.</p>
<h4 id="procedure">Procedure</h4>
<ol>
<li>First, make sure you install TWRP and then flash Magisk through it.</li>
<li>Setup Magisk in your phone.</li>
<li>Connect your phone to your Computer and type adb shell [Ensure that you have adb setup properly].</li>
<li>Now, become root by typing <strong>su</strong> in the shell on your PC.</li>
<li>Copy/Paste the following code in the shell.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">for</span> PARTITION in <span class="s2">&#34;boot&#34;</span> <span class="s2">&#34;boot_a&#34;</span> <span class="s2">&#34;boot_b&#34;</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="nv">BLOCK</span><span class="o">=</span><span class="k">$(</span>find /dev/block <span class="se">\(</span> -type b -o -type c -o -type l <span class="se">\)</span> -iname <span class="s2">&#34;</span><span class="nv">$PARTITION</span><span class="s2">&#34;</span> -print -quit 2&gt;/dev/null<span class="k">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">[</span> -n <span class="s2">&#34;</span><span class="nv">$BLOCK</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$PARTITION</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="k">$(</span>readlink -f <span class="s2">&#34;</span><span class="nv">$BLOCK</span><span class="s2">&#34;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">fi</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span></code></pre></div><p>This command will display the boot partition paths for both A/B and A-only devices.</p>
<p><strong>Note: On <a href="https://source.android.com/docs/core/ota/ab">A/B devices</a>, the loop command will display the boot partition paths for both slots, something like this!</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nv">boot_a</span> <span class="o">=</span> /dev/block/sda40
</span></span><span class="line"><span class="cl"><span class="nv">boot_b</span> <span class="o">=</span> /dev/block/sda41
</span></span></code></pre></div><p>In this case, you can extract the image corresponding to your currently active slot.To determine the active slot, enter the command <code>getprop ro.boot.slot_suffix</code>. If the output is _a, use the path for boot_a; otherwise, use the path for boot_b.</p>
<ol start="6">
<li>Finally, use the following command to extract the image from the specified boot path:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>&lt;boot_partition_path&gt; <span class="nv">of</span><span class="o">=</span>&lt;output_path&gt;
</span></span></code></pre></div><p>For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">dd <span class="k">if</span><span class="o">=</span>/dev/block/mmcblk0p42 <span class="nv">of</span><span class="o">=</span>/sdcard/boot_a.img
</span></span></code></pre></div><p>I hope this did work for you, as it did indeed work for me!</p>
<p>CREDITS : <a href="https://gist.github.com/gitclone-url/a1f693b64d8f8701ec24477a2ccaab87">Here</a></p>
]]></content:encoded>
    </item>
  </channel>
</rss>
